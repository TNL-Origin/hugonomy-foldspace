/* global chrome */
// üß± VibeAI Unified HUD Container (v2.11.10-UNIHUD-ALPHA)
// Runs in main page context (not iframe) to avoid pointer-events conflicts

// Debug mode flag - SET TO FALSE FOR PRODUCTION
// SECURITY NOTE: Debug APIs expose internal state and allow page scripts to manipulate
// the extension. Always set VIBEAI_DEBUG_ENABLED = false before public release.
const VIBEAI_DEBUG_ENABLED = false;

/**
 * Escapes HTML special characters to prevent XSS injection
 * @param {string} str - Raw string that may contain HTML
 * @returns {string} - HTML-safe escaped string
 */
// SECURITY NOTE: All user-sourced content MUST be escaped before insertion into innerHTML
// to prevent XSS attacks. Use escapeHtml() for any data coming from parsed pages or threads.
// DO NOT insert raw t.title, t.content, t.source, IDs, or other parsed data directly.
function escapeHtml(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.textContent = String(str);
  return div.innerHTML;
}

console.log('[VibeAI UniHUD] üß± Initializing Unified HUD Container...');

// üåó Theme System - Auto-detect + Manual Toggle
let currentTheme = 'dark';
let manualOverride = false;

// Detect system/browser theme preference
async function detectTheme() {
  const systemDark = window.matchMedia('(prefers-color-scheme: dark)');

  // Check for saved preference
  try {
    const stored = await chrome.storage.local.get('vibeaiTheme');
    if (stored.vibeaiTheme) {
      manualOverride = true;
      return stored.vibeaiTheme;
    }
  } catch {
    console.log('[VibeAI Theme] Storage check skipped (may not be available yet)');
  }

  // Default to system preference
  return systemDark.matches ? 'dark' : 'light';
}

// Apply theme to document
function applyTheme(theme) {
  currentTheme = theme;
  document.documentElement.classList.remove('theme-light', 'theme-dark');
  document.documentElement.classList.add(`theme-${theme}`);

  // Add switching animation class briefly
  document.documentElement.classList.add('theme-switching');
  setTimeout(() => {
    document.documentElement.classList.remove('theme-switching');
  }, 600);

  console.log(`[VibeAI HUD] üåó Theme set to ${theme.toUpperCase()}`);
}

// Toggle theme (manual override)
function toggleTheme() {
  manualOverride = true;
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
  applyTheme(newTheme);

  // Persist preference
  try {
    chrome.storage.local.set({ vibeaiTheme: newTheme });
  } catch (e) {
    console.log('[VibeAI Theme] Could not save preference:', e);
  }
}

// Watch for system theme changes (only if no manual override)
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
  if (!manualOverride) {
    applyTheme(e.matches ? 'dark' : 'light');
  }
});

// üé® Phase Œî.9.1 - Empathic Hover Lexicon System
// Lexicon selector (youth / pro / clinical / mythic)
let ACTIVE_LEXICON = 'youth'; // Default to youth-friendly language
let ACTIVE_TONE_MAP = null;

// Load tone map dynamically from extension package
async function loadToneMap(lexicon = ACTIVE_LEXICON) {
  try {
    const url = chrome.runtime.getURL(`src/data/toneMap_${lexicon}.json`);
    const res = await fetch(url);
    ACTIVE_TONE_MAP = await res.json();
    console.log(`[VibeAI Lexicon] ‚úÖ Loaded tone map: ${lexicon}`, ACTIVE_TONE_MAP);
    return true;
  } catch (err) {
    console.error(`[VibeAI Lexicon] ‚ùå Failed to load tone map: ${lexicon}`, err);
    ACTIVE_TONE_MAP = null;
    return false;
  }
}

// Switch lexicon (with validation and reload)
async function switchLexicon(newLexicon) {
  const validLexicons = ['youth', 'pro', 'clinical', 'mythic'];
  if (!validLexicons.includes(newLexicon)) {
    console.warn(`[VibeAI Lexicon] ‚ö†Ô∏è Invalid lexicon: ${newLexicon}. Valid options: ${validLexicons.join(', ')}`);
    return false;
  }

  console.log(`[VibeAI Lexicon] üîÑ Switching to ${newLexicon} lexicon...`);
  ACTIVE_LEXICON = newLexicon;
  const loaded = await loadToneMap(newLexicon);

  if (loaded) {
    // Save preference
    try {
      await chrome.storage.local.set({ vibeaiLexicon: newLexicon });
    } catch (e) {
      console.log('[VibeAI Lexicon] Could not save preference:', e);
    }

    // Phase Œî9.2: Force tooltip refresh on active canvas instances
    document.querySelectorAll('.vibeai-tooltip').forEach(tip => {
      tip.dataset.lexicon = newLexicon;
    });

    // Trigger tooltip update on canvas if hovering
    const canvasEvent = new CustomEvent('vibeai:lexiconChanged', { detail: { lexicon: newLexicon } });
    document.dispatchEvent(canvasEvent);

    console.log(`[VibeAI Lexicon] ‚úÖ Switched to ${newLexicon} lexicon`);
    return true;
  }
  return false;
}

// Load saved lexicon preference
async function loadLexiconPreference() {
  try {
    const stored = await chrome.storage.local.get('vibeaiLexicon');
    if (stored.vibeaiLexicon) {
      ACTIVE_LEXICON = stored.vibeaiLexicon;
      console.log(`[VibeAI Lexicon] üìñ Restored preference: ${ACTIVE_LEXICON}`);
    }
  } catch {
    console.log('[VibeAI Lexicon] Using default lexicon (youth)');
  }
}

// Expose lexicon switcher globally for console access and debugging
// SECURITY: Only expose in debug mode to prevent page scripts from manipulating extension
if (VIBEAI_DEBUG_ENABLED) {
  window.__vibeai_switchLexicon = switchLexicon;
  console.log('[VibeAI] Debug API enabled: window.__vibeai_switchLexicon');
}

// üé® Phase Œî.8 - FoldSpace Canvas Mood Field
// Feature Flags
const FEATURE_FLAGS = {
  ENABLE_CANVAS_MOOD: true  // Set to false for legacy static tiles fallback
};

// Canvas Configuration
const CANVAS_CONFIG = {
  width: 380,
  height: 120,
  emojis: [
    { symbol: 'üåä', tone: 'calm', x: 50, baseY: 60 },
    { symbol: '‚ö°', tone: 'urgent', x: 130, baseY: 60 },
    { symbol: 'üîÆ', tone: 'reflective', x: 210, baseY: 60 },
    { symbol: '‚öôÔ∏è', tone: 'dissonant', x: 290, baseY: 60 },
    { symbol: '‚ú®', tone: 'resonant', x: 370, baseY: 60 }
  ],
  animation: {
    fps: 20,
    bobAmplitude: 8,
    bobSpeed: 0.002,
    glowPulseSpeed: 0.003
  },
  particles: {
    maxCount: 10,
    speed: 0.3,
    fadeRate: 0.98,
    size: 2
  },
  colors: {
    dark: {
      glow: 'rgba(0, 198, 255, 0.6)',
      particle: 'rgba(0, 198, 255, 0.4)',
      inactive: 'rgba(255, 255, 255, 0.3)'
    },
    light: {
      glow: 'rgba(0, 120, 180, 0.6)',
      particle: 'rgba(0, 120, 180, 0.4)',
      inactive: 'rgba(100, 100, 100, 0.3)'
    }
  }
};

// Platform detection
const PLATFORM = (() => {
  const hostname = window.location.hostname || '';
  if (hostname.includes('claude.ai')) return 'claude';
  if (hostname.includes('chatgpt') || hostname.includes('openai')) return 'chatgpt';
  if (hostname.includes('gemini.google')) return 'gemini';
  if (hostname.includes('copilot')) return 'copilot';
  return 'unknown';
})();

// Claude thread selectors (centralized for easy updates)
const CLAUDE_SELECTORS = [
  '[data-test-render-count]',
  '.font-claude-message',
  'div[class*="font-user-message"]',
  'div[class*="font-claude"]',
  '[class*="MessageContent"]'
];

// üé® FoldSpaceCanvas Class - Phase Œî.8
class FoldSpaceCanvas {
  constructor(canvasElement) {
    this.canvas = canvasElement;
    this.ctx = canvasElement.getContext('2d');
    this.activeTone = 'calm';
    this.intensity = 0.6; // Phase Œî.9: HugoScore-driven intensity (0-1)
    this.particles = [];
    this.animationId = null;
    this.startTime = Date.now();
    this.hoveredEmoji = null;
    this.isRunning = false;

    // Bind methods
    this.animate = this.animate.bind(this);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    this.handleClick = this.handleClick.bind(this);

    // Set canvas size
    this.canvas.width = CANVAS_CONFIG.width;
    this.canvas.height = CANVAS_CONFIG.height;

    // Initialize particle pool
    for (let i = 0; i < CANVAS_CONFIG.particles.maxCount; i++) {
      this.particles.push(this.createParticle());
    }

    // Phase Œî.9.1: Tooltip element for empathic hover lexicon
    this.tooltip = document.createElement('div');
    this.tooltip.className = 'vibeai-tooltip';
    Object.assign(this.tooltip.style, {
      position: 'fixed',
      padding: '8px 12px',
      borderRadius: '10px',
      fontSize: '14px',
      lineHeight: '1.5',
      fontFamily: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
      fontWeight: '500',
      opacity: '0',
      transition: 'opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1), transform 0.15s cubic-bezier(0.4, 0, 0.2, 1)', // Phase Œî.9.3: Faster transitions (was 0.25s)
      pointerEvents: 'none',
      zIndex: '2147483648', // Phase Œî9.2.3: Above HUD (2147483647 + 1)
      backdropFilter: 'blur(8px) saturate(150%)',
      WebkitBackdropFilter: 'blur(8px) saturate(150%)',
      boxShadow: '0 4px 16px rgba(0, 0, 0, 0.2)',
      maxWidth: '280px',
      textAlign: 'left'
    });
    document.body.appendChild(this.tooltip);

    // Cursor tracking state (smooth follow)
    this.mouse = { x: 0, y: 0, targetX: 0, targetY: 0 };

    // Smooth tooltip tracking (Phase Œî.9.3: Faster easing for snappier response)
    this.tooltipTracker = setInterval(() => {
      this.mouse.x += (this.mouse.targetX - this.mouse.x) * 0.5; // Increased from 0.25 for faster follow
      this.mouse.y += (this.mouse.targetY - this.mouse.y) * 0.5;
      this.tooltip.style.left = `${this.mouse.x}px`;
      this.tooltip.style.top = `${this.mouse.y}px`;
    }, 16); // ~60fps

    console.log('[VibeAI Canvas] Initialized');
  }

  // Phase Œî.9: Set intensity (HugoScore-driven)
  setIntensity(value) {
    this.intensity = Math.max(0, Math.min(1, value)); // Clamp 0-1
  }

  createParticle() {
    return {
      x: Math.random() * CANVAS_CONFIG.width,
      y: Math.random() * CANVAS_CONFIG.height,
      vx: (Math.random() - 0.5) * CANVAS_CONFIG.particles.speed,
      vy: (Math.random() - 0.5) * CANVAS_CONFIG.particles.speed,
      alpha: Math.random() * 0.5,
      active: false
    };
  }

  start() {
    if (this.isRunning) return;
    this.isRunning = true;

    // Add event listeners
    this.canvas.addEventListener('mousemove', this.handleMouseMove);
    this.canvas.addEventListener('click', this.handleClick);

    // Phase Œî9.2: Listen for lexicon changes to refresh tooltip
    document.addEventListener('vibeai:lexiconChanged', () => {
      if (this.hoveredEmoji) {
        this.updateTooltip();
      }
    });

    // Start animation loop
    this.animate();
    console.log('[VibeAI Canvas] Started successfully');
  }

  setActiveTone(tone) {
    if (this.activeTone !== tone) {
      this.activeTone = tone;
      console.log(`[VibeAI Canvas] Active tone: ${tone}`);

      // Activate particles on tone change
      this.particles.forEach((p, i) => {
        if (i < 5) {
          p.active = true;
          p.alpha = 0.6;
        }
      });
    }
  }

  handleMouseMove(e) {
    const rect = this.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Phase Œî.9.1: Update cursor tracking for tooltip
    this.mouse.targetX = e.clientX + 14;
    this.mouse.targetY = e.clientY + 14;

    this.hoveredEmoji = null;

    CANVAS_CONFIG.emojis.forEach(emoji => {
      const dx = x - emoji.x;
      const dy = y - emoji.baseY;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Phase Œî.9.3: Larger hover radius for easier triggering (was 20px)
      if (distance < 30) {
        this.hoveredEmoji = emoji.tone;
        this.canvas.style.cursor = 'pointer';
      }
    });

    if (!this.hoveredEmoji) {
      this.canvas.style.cursor = 'default';
    }

    // Phase Œî.9.1: Update tooltip based on hover state
    this.updateTooltip();
  }

  // Phase Œî.9.1: Update tooltip content and visibility
  updateTooltip() {
    if (this.hoveredEmoji && ACTIVE_TONE_MAP) {
      const tone = this.hoveredEmoji.toLowerCase(); // Phase Œî9.2: normalize key
      const lex = ACTIVE_TONE_MAP[tone];

      if (lex && lex.title && lex.phrase) {
        // Build tooltip HTML
        this.tooltip.innerHTML = `
          <div style="font-size: 15px; font-weight: 600; margin-bottom: 4px; color: ${lex.color || '#888'};">
            ${lex.title}
          </div>
          <div style="font-size: 13px; font-weight: 400; opacity: 0.9;">
            ${lex.phrase}
          </div>
        `;

        // Theme-aware background
        const isDark = currentTheme === 'dark';
        this.tooltip.style.background = isDark ? 'rgba(17, 17, 17, 0.95)' : 'rgba(255, 255, 255, 0.95)';
        this.tooltip.style.color = isDark ? '#ffffff' : '#111111';
        this.tooltip.style.border = `1.5px solid ${lex.color || '#888'}`;
        this.tooltip.style.opacity = '1';
        this.tooltip.style.transform = 'translateY(0px) scale(1)';

        console.log(`[VibeAI Lexicon] Tooltip active for tone: ${tone} | ${lex.title}`);
      } else {
        // Phase Œî9.2: Show fallback if lexicon data missing
        console.warn(`[VibeAI Lexicon] ‚ö†Ô∏è No lexicon data for tone: ${tone}`, ACTIVE_TONE_MAP);
        this.tooltip.textContent = `${tone} (lexicon not loaded)`;
        this.tooltip.style.opacity = '0.7';
      }
    } else {
      // Hide tooltip
      this.tooltip.style.opacity = '0';
      this.tooltip.style.transform = 'translateY(5px) scale(0.95)';
    }
  }

  handleClick(e) {
    if (this.hoveredEmoji) {
      console.log(`[VibeAI Canvas] Clicked tone: ${this.hoveredEmoji}`);
      this.setActiveTone(this.hoveredEmoji);

      // Create ripple effect
      const rect = this.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      this.particles.forEach((p, i) => {
        if (i < 3) {
          p.x = x;
          p.y = y;
          p.active = true;
          p.alpha = 0.8;
          const angle = (i / 3) * Math.PI * 2;
          p.vx = Math.cos(angle) * CANVAS_CONFIG.particles.speed * 2;
          p.vy = Math.sin(angle) * CANVAS_CONFIG.particles.speed * 2;
        }
      });
    }
  }

  animate() {
    if (!this.isRunning) return;

    // Skip if tab is hidden (performance)
    if (document.hidden) {
      this.animationId = requestAnimationFrame(this.animate);
      return;
    }

    const now = Date.now();
    const elapsed = now - this.startTime;

    // Clear canvas
    this.ctx.clearRect(0, 0, CANVAS_CONFIG.width, CANVAS_CONFIG.height);

    // Get theme colors
    const isDark = currentTheme === 'dark';
    const colors = isDark ? CANVAS_CONFIG.colors.dark : CANVAS_CONFIG.colors.light;

    // Draw particles
    this.particles.forEach(p => {
      if (!p.active) return;

      p.x += p.vx;
      p.y += p.vy;
      p.alpha *= CANVAS_CONFIG.particles.fadeRate;

      // Deactivate if too faint
      if (p.alpha < 0.05) {
        p.active = false;
        return;
      }

      // Wrap around edges
      if (p.x < 0) p.x = CANVAS_CONFIG.width;
      if (p.x > CANVAS_CONFIG.width) p.x = 0;
      if (p.y < 0) p.y = CANVAS_CONFIG.height;
      if (p.y > CANVAS_CONFIG.height) p.y = 0;

      // Draw particle
      this.ctx.fillStyle = colors.particle.replace(/[\d.]+\)$/, `${p.alpha})`);
      this.ctx.beginPath();
      this.ctx.arc(p.x, p.y, CANVAS_CONFIG.particles.size, 0, Math.PI * 2);
      this.ctx.fill();
    });

    // Draw emojis
    CANVAS_CONFIG.emojis.forEach(emoji => {
      const isActive = emoji.tone === this.activeTone;
      const isHovered = emoji.tone === this.hoveredEmoji;

      // Phase Œî.9: Intensity-driven dynamics
      const intensity = this.intensity || 0.6;
      const intensityMod = 0.5 + 0.5 * intensity; // 0.5-1.0 range

      // Calculate bob animation (amplitude scaled by intensity)
      const bobAmplitude = CANVAS_CONFIG.animation.bobAmplitude * intensityMod;
      const bobOffset = Math.sin(elapsed * CANVAS_CONFIG.animation.bobSpeed + emoji.x) * bobAmplitude;
      const y = emoji.baseY + bobOffset;

      // Glow effect for active emoji (size and opacity scaled by intensity)
      if (isActive) {
        const glowPulse = 0.5 + 0.5 * Math.sin(elapsed * CANVAS_CONFIG.animation.glowPulseSpeed);
        const baseGlowSize = 30 + glowPulse * 15;
        const glowSize = baseGlowSize * (0.7 + 0.3 * intensity); // 70%-100% based on intensity

        // Dynamic glow color with intensity-based alpha
        const glowAlpha = 0.3 + 0.3 * intensity; // 0.3-0.6 range
        const glowColor = colors.glow.replace(/[\d.]+\)$/, `${glowAlpha})`);

        const gradient = this.ctx.createRadialGradient(emoji.x, y, 0, emoji.x, y, glowSize);
        gradient.addColorStop(0, glowColor);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(emoji.x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
      }

      // Draw emoji (size slightly affected by intensity)
      const emojiSize = isHovered ? 42 : (32 * (0.95 + 0.05 * intensity));
      this.ctx.font = `${Math.round(emojiSize)}px Arial`;
      this.ctx.textAlign = 'center';
      this.ctx.textBaseline = 'middle';

      // Add shadow for inactive emojis
      if (!isActive) {
        this.ctx.globalAlpha = 0.4;
      }

      this.ctx.fillText(emoji.symbol, emoji.x, y);
      this.ctx.globalAlpha = 1.0;
    });

    // Continue animation loop at ~20 FPS
    setTimeout(() => {
      this.animationId = requestAnimationFrame(this.animate);
    }, 1000 / CANVAS_CONFIG.animation.fps);
  }

  destroy() {
    this.isRunning = false;

    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }

    this.canvas.removeEventListener('mousemove', this.handleMouseMove);
    this.canvas.removeEventListener('click', this.handleClick);

    // Phase Œî.9.1: Cleanup tooltip
    if (this.tooltipTracker) {
      clearInterval(this.tooltipTracker);
      this.tooltipTracker = null;
    }

    if (this.tooltip && this.tooltip.parentNode) {
      this.tooltip.parentNode.removeChild(this.tooltip);
      this.tooltip = null;
    }

    console.log('[VibeAI Canvas] Destroyed');
  }
}

// üß† Phase Œî.9 - HugoScore Bridge (Emotion ‚Üí Quantified Resonance)

// Tone emotional weight mapping (0-100 scale)
const HUGO_TONE_WEIGHTS = {
  calm: 40,
  urgent: 75,
  reflective: 60,
  dissonant: 30,
  resonant: 90
};

// Calculate HugoScore from text content (0-100)
function calculateHugoScore(text, tone = 'calm') {
  if (!text) return 50;

  const lower = text.toLowerCase();
  let score = HUGO_TONE_WEIGHTS[tone] || 50;

  // Positive modifiers
  if (lower.match(/great|love|amazing|excellent|perfect|wonderful|fantastic/)) score += 20;
  if (lower.match(/harmony|resonance|aligned|flow|synergy|coherent/)) score += 15;
  if (lower.match(/beautiful|elegant|graceful|smooth|clear/)) score += 10;

  // Urgent/action modifiers
  if (lower.match(/urgent|now|critical|fast|immediately|asap/)) score += 15;
  if (lower.match(/important|priority|deadline|must|need/)) score += 10;

  // Negative modifiers
  if (lower.match(/sad|confus|error|problem|difficult|struggle/)) score -= 20;
  if (lower.match(/frustrat|annoying|wrong|broken|fail/)) score -= 15;
  if (lower.match(/bad|poor|terrible|awful|horrible/)) score -= 10;

  // Reflective modifiers
  if (lower.match(/think|consider|ponder|wonder|maybe|perhaps/)) score += 5;
  if (lower.match(/interest|curious|explore|discover/)) score += 10;

  // Message length factor (longer messages = more engagement)
  const wordCount = text.split(/\s+/).length;
  if (wordCount > 50) score += 10;
  else if (wordCount > 20) score += 5;

  // Clamp to 0-100 range
  return Math.min(100, Math.max(0, score));
}

// Update HugoScore Bridge (connects parser ‚Üí canvas ‚Üí intensity)
function updateHugoBridge(text) {
  if (!text || !foldSpaceCanvas) return;

  // Detect tone and calculate score
  const tone = detectDominantTone(text);
  const score = calculateHugoScore(text, tone);
  const intensity = score / 100; // Normalize to 0-1

  // Update global state
  window.VIBEAI_LAST_TONE = tone;
  window.VIBEAI_LAST_SCORE = score;

  // Update canvas with tone and intensity
  if (foldSpaceCanvas && foldSpaceCanvas.setActiveTone) {
    foldSpaceCanvas.setActiveTone(tone);

    // Set intensity for dynamic visual effects
    if (typeof foldSpaceCanvas.setIntensity === 'function') {
      foldSpaceCanvas.setIntensity(intensity);
    } else {
      foldSpaceCanvas.intensity = intensity; // Fallback direct property
    }
  }

  console.log(`[HugoBridge] Tone: ${tone} | HugoScore: ${score} | Intensity: ${intensity.toFixed(2)}`);
}

// Tone Detection Heuristic (Phase Œî.8 - enhanced in Œî.9 with HugoScore)
function detectDominantTone(text) {
  if (!text) return 'calm';

  const lower = text.toLowerCase();

  // Keyword maps for each tone
  const toneKeywords = {
    urgent: ['urgent', 'immediately', 'asap', 'critical', 'emergency', 'now', 'hurry', 'deadline'],
    dissonant: ['error', 'problem', 'issue', 'bug', 'fail', 'broken', 'wrong', 'conflict'],
    resonant: ['perfect', 'excellent', 'amazing', 'brilliant', 'harmony', 'aligned', 'synergy'],
    reflective: ['think', 'consider', 'reflect', 'ponder', 'analyze', 'contemplate', 'perhaps'],
    calm: ['calm', 'peace', 'relax', 'steady', 'gentle', 'slow', 'balanced']
  };

  // Score each tone
  const scores = {};
  for (const [tone, keywords] of Object.entries(toneKeywords)) {
    scores[tone] = keywords.filter(keyword => lower.includes(keyword)).length;
  }

  // Find highest scoring tone
  let maxScore = 0;
  let dominantTone = 'calm';

  for (const [tone, score] of Object.entries(scores)) {
    if (score > maxScore) {
      maxScore = score;
      dominantTone = tone;
    }
  }

  return dominantTone;
}

// Global canvas instance
let foldSpaceCanvas = null;

// 1. Create unified HUD container
function renderHUDContainer() {
  if (document.getElementById('vibeai-unified-hud')) {
    console.log('[VibeAI UniHUD] Container already exists');
    return document.getElementById('vibeai-unified-hud');
  }

  const hud = document.createElement('div');
  hud.id = 'vibeai-unified-hud';
  hud.style.cssText = `
    position: fixed;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
    width: 360px;
    max-height: 85vh;
  background: rgba(30, 30, 40, var(--vibeai-hud-opacity, 0.12));
  backdrop-filter: blur(18px) saturate(180%);
  -webkit-backdrop-filter: blur(18px) saturate(180%);
  transition: background 0.4s ease;
    border-radius: 12px;
    border: 1px solid rgba(0, 212, 255, 0.4);
    box-shadow: 0 0 30px rgba(0, 170, 255, 0.3), 0 8px 32px rgba(0, 0, 0, 0.4);
    color: #fff;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
    z-index: 2147483647;
    pointer-events: auto;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  `;

  // Header with controls (traditional browser-style top bar)
  const header = document.createElement('div');
  header.style.cssText = `
    padding: 12px 16px;
    border-bottom: 2px solid rgba(0, 170, 255, 0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
  `;
  header.innerHTML = `
    <div id="vibeai-header-title" style="flex: 1; text-align: center;">
      <div style="font-size: 1.15em; font-weight: bold; color: #00d4ff; letter-spacing: 1.5px;">VibeAI Thread Inspector</div>
    </div>
    <div style="display: flex; gap: 6px; align-items: center;">
      <button class="vibeai-icon-btn" id="vibeai-toggle-canvas" title="Hide Canvas" style="font-size: 18px; font-weight: bold; min-width: 32px; min-height: 32px;">‚Äî</button>
      <button class="vibeai-icon-btn" id="vibeai-close-hud" title="Close HUD">‚úï</button>
    </div>
  `;
  hud.appendChild(header);

  // Utility toolbar: left-aligned utility buttons and right-aligned Reanalyze
  const utils = document.createElement('div');
  utils.id = 'vibeai-utils';
  utils.style.cssText = `
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 16px;
    border-bottom: 1px solid rgba(0, 170, 255, 0.15);
    font-size: 0.85em;
    opacity: 0.95;
    gap: 12px;
  `;
  utils.innerHTML = `
    <div class="hud-toolbar" style="width:100%; display:flex; justify-content:space-between; align-items:center; gap:8px;">
      <div class="hud-button-group" style="display:flex; gap:8px; align-items:center;">
        <button id="vibeai-consent" class="hud-button" style="background:none; border:none; color:#00d4ff; cursor:pointer; padding:6px 8px;">Consent</button>
        <button id="vibeai-privacy" class="hud-button" style="background:none; border:none; color:#00d4ff; cursor:pointer; padding:6px 8px;">Privacy</button>
        <button id="vibeai-report-bug" class="hud-button" style="background:none; border:none; color:#00d4ff; cursor:pointer; padding:6px 8px;">Report Bug</button>
      </div>
      <div style="margin-left:12px;">
        <button class="reanalyze-button vibeai-btn" id="vibeai-reanalyze">Reanalyze</button>
      </div>
    </div>
  `;
  hud.appendChild(utils);

  // FoldSpace header visual ‚Äî Canvas (Phase Œî.8) or legacy tiles (fallback)
  const headerCanvas = document.createElement('div');
  headerCanvas.id = 'vibeai-foldspace-header';
  headerCanvas.style.cssText = `
    padding: 12px 16px;
    background: linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.15));
    border-bottom: 1px solid rgba(0, 170, 255, 0.12);
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: center;
  `;

  // Helper to resolve extension asset URLs when available
  function assetUrl(relPath) {
    try {
      if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.getURL) {
        return chrome.runtime.getURL(relPath);
      }
  } catch { /* ignore */ }
    return relPath;
  }

  // üé® Phase Œî.8 - Canvas Mood Field or Legacy Tiles
  if (FEATURE_FLAGS.ENABLE_CANVAS_MOOD) {
    // NEW: Canvas-based mood visualization
    headerCanvas.innerHTML = `
      <canvas id="foldspace-canvas"
        width="${CANVAS_CONFIG.width}"
        height="${CANVAS_CONFIG.height}"
        style="display:block;width:100%;height:auto;max-width:${CANVAS_CONFIG.width}px;">
      </canvas>
    `;
  } else {
    // LEGACY: Static tile fallback (preserved for compatibility)

    // üåÄ Hugonomic Tile Dynamics System v2.0 - Tiles That Breathe
    // Update tile breathing animation
    function updateTileBreathing() {
      const t = Date.now() / 6000;
      const globalOpacity = 0.95 + 0.05 * Math.sin(t * 2 * Math.PI);

      const tilesContainer = document.getElementById('vibeai-foldspace-canvas-tiles');
      if (!tilesContainer) return;

      const tileElements = tilesContainer.querySelectorAll('.foldspace-tile');
      tileElements.forEach((tile) => {
        tile.style.opacity = globalOpacity;
      });
    }

    // Start global breath cycle (6-second rhythm)
    setInterval(updateTileBreathing, 50);

  // Mood tiles order: calm, urgent, reflective, dissonant, resonant
  // Colors matched to FoldSpace Mood Color System (v1 Draft)
  const tiles = [
    { key: 'calm', bg: 'linear-gradient(90deg,#00C6FF,#0072FF)'} ,           // Cyan ‚Üí Deep Blue
    { key: 'urgent', bg: 'linear-gradient(90deg,#FF9900,#FF0033)'} ,         // Amber ‚Üí Red
    { key: 'reflective', bg: 'linear-gradient(90deg,#9B5DE5,#3A0CA3)'} ,     // Purple ‚Üí Deep Purple
    { key: 'dissonant', bg: 'linear-gradient(90deg,#556270,#4E4376)'} ,      // Slate Gray ‚Üí Plum
    { key: 'resonant', bg: 'linear-gradient(90deg,#00F5A0,#FF0080)'}          // Teal ‚Üí Magenta
  ];

  // legacy spiral asset (kept for compatibility) ‚Äî not used when tiles show symbol+label
  assetUrl('icons/icon-full.svg');

  // Map tile keys to a symbol (emoji fallback) and label text ‚Äî visual + textual per tile
  // Icons chosen for symbolic resonance with each mood state
  const tileMeta = {
    calm: { emoji: 'üåä', label: 'Calm' },              // Still waters, peaceful flow
    urgent: { emoji: '‚ö°', label: 'Urgent' },          // Electric intensity, immediate action
    reflective: { emoji: 'üîÆ', label: 'Reflective' },   // Crystal ball, inner contemplation
    dissonant: { emoji: '‚öôÔ∏è', label: 'Dissonant' },    // Gears grinding, tension
    resonant: { emoji: '‚ú®', label: 'Resonant' }       // Sparkles, harmonic alignment
  };

  headerCanvas.innerHTML = `
    <div id="vibeai-foldspace-canvas-tiles" style="display:flex;gap:6px;align-items:center;justify-content:center;width:100%;">
      ${tiles.map(t => {
        const m = tileMeta[t.key] || { emoji: 'üåå', label: t.key };
        // Dynamic tiles with breath cycle and hover effects
        return `
        <div class="foldspace-tile" data-tone="${t.key}"
          style="flex:1;height:56px;border-radius:12px;background:${t.bg};
          position:relative;overflow:hidden;display:flex;flex-direction:column;
          align-items:center;justify-content:center;
          box-shadow:0 2px 8px rgba(0,0,0,0.2), 0 0 0 2px rgba(255,255,255,0.2);
          gap:2px;cursor:pointer;
          transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          opacity:0.95;">
          <div class="foldspace-tile-symbol"
            style="font-size:26px;line-height:1;
            filter:drop-shadow(0 2px 4px rgba(0,0,0,0.4));
            transition:transform 0.3s ease;">${m.emoji}</div>
          <div class="foldspace-tile-label"
            style="font-size:10px;font-weight:700;color:rgba(255,255,255,0.95);
            letter-spacing:0.5px;text-shadow:0 1px 3px rgba(0,0,0,0.5);
            text-transform:uppercase;line-height:1;">${m.label}</div>
        </div>`;
      }).join('')}
    </div>
  `;

  // Add hover effects to tiles
  const tileElements = headerCanvas.querySelectorAll('.foldspace-tile');
  tileElements.forEach(tile => {
    tile.addEventListener('mouseenter', () => {
      tile.style.transform = 'scale(1.05)';
      tile.style.boxShadow = '0 4px 16px rgba(0,0,0,0.3), 0 0 0 3px rgba(255,255,255,0.4), 0 0 20px rgba(255,255,255,0.3)';
      const symbol = tile.querySelector('.foldspace-tile-symbol');
      if (symbol) symbol.style.transform = 'scale(1.15)';
    });

    tile.addEventListener('mouseleave', () => {
      tile.style.transform = 'scale(1)';
      tile.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2), 0 0 0 2px rgba(255,255,255,0.2)';
      const symbol = tile.querySelector('.foldspace-tile-symbol');
      if (symbol) symbol.style.transform = 'scale(1)';
    });
  });
  } // End FEATURE_FLAGS.ENABLE_CANVAS_MOOD check

  hud.appendChild(headerCanvas);

  // Thread feed container
  const threadFeed = document.createElement('div');
  threadFeed.id = 'vibeai-thread-feed-unified';
  threadFeed.style.cssText = `
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 12px 16px;
  `;
  threadFeed.innerHTML = `<p style="text-align: center; color: #999; padding: 30px 20px; font-style: italic;">üß† No threads detected yet. Send your first message in the chat ‚Äî FoldSpace will map the conversation here and threads will appear.</p>`;
  hud.appendChild(threadFeed);

  // Footer with transparency slider (left) and theme toggle (right)
  const footer = document.createElement('div');
  footer.id = 'vibeai-hud-footer';
  footer.style.cssText = `
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 16px;
    border-top: 1px solid rgba(0, 170, 255, 0.15);
    background: linear-gradient(180deg, rgba(0,0,0,0.15), rgba(0,0,0,0.25));
  `;
  footer.innerHTML = `
    <div style="display:flex; align-items:center; gap:8px;">
      <span style="font-size:11px; opacity:0.7;">ü´ß Opacity</span>
      <input
        id="vibeai-opacity-slider"
        type="range"
        min="0.10"
        max="0.80"
        step="0.01"
        value="0.12"
        title="Adjust HUD transparency"
        style="width:80px; accent-color:#00C6FF; cursor:pointer;"
      />
    </div>
    <button id="vibeai-theme-toggle" title="Toggle theme (${currentTheme === 'dark' ? 'Switch to light' : 'Switch to dark'})"
      style="background:none; border:none; cursor:pointer; font-size:22px; padding:8px;
      border-radius:8px; transition:all 0.3s ease;
      filter:drop-shadow(0 2px 4px rgba(0,0,0,0.3));">
      ${currentTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô'}
    </button>
    <button id="vibeai-lexicon-toggle" title="Toggle lexicon (Current: ${ACTIVE_LEXICON})"
      style="background:none; border:none; cursor:pointer; font-size:18px; padding:8px;
      border-radius:8px; transition:all 0.3s ease;
      filter:drop-shadow(0 2px 4px rgba(0,0,0,0.3)); font-weight:600;">
      ${ACTIVE_LEXICON === 'youth' ? 'üéì' : 'üíº'}
    </button>
  `;
  hud.appendChild(footer);

  document.body.appendChild(hud);
  // Ensure canvas layer is present before HUD toggles attempt to access it
  ensureCanvasLayer();
  injectHUDStyles();
  attachEventListeners();

  // Initialize theme system
  detectTheme().then(theme => {
    applyTheme(theme);
  });

  // üé® Phase Œî.9.1 - Load lexicon preference and tone map
  // Phase Œî9.2.2: Wait for lexicon to load BEFORE initializing canvas
  loadLexiconPreference().then(() => {
    return loadToneMap();
  }).then(() => {
    console.log('[VibeAI Lexicon] ‚úÖ Lexicon loaded, initializing canvas...');
    initializeFoldSpaceCanvas();
  }).catch(err => {
    console.warn('[VibeAI Lexicon] Failed to load initial lexicon:', err);
    // Still initialize canvas with fallback
    initializeFoldSpaceCanvas();
  });

  // üé® Phase Œî.8 - Initialize FoldSpace Canvas (after lexicon loads)
  function initializeFoldSpaceCanvas() {
    if (!FEATURE_FLAGS.ENABLE_CANVAS_MOOD) return;

    const canvasEl = document.getElementById('foldspace-canvas');
    if (canvasEl) {
      try {
        foldSpaceCanvas = new FoldSpaceCanvas(canvasEl);
        foldSpaceCanvas.start();

        // ‚öôÔ∏è Phase Œî.8.2 - Page-Context Debug Bridge (Cross-Context Communication)
        // SECURITY: Only enable debug APIs when VIBEAI_DEBUG_ENABLED is true
        if (VIBEAI_DEBUG_ENABLED) {
          try {
            // Expose in content script context (for internal debugging)
            window.foldSpaceCanvas = foldSpaceCanvas;

            // Inject debug API into page context (accessible from DevTools console)
            const bridgeScript = document.createElement('script');
            bridgeScript.id = 'vibeai-debug-bridge';
            bridgeScript.textContent = `
              (function() {
                if (window.__vibeai_canvas_debug) {
                  console.log('[VibeAI Canvas] Debug API already exists, skipping injection');
                  return;
                }

                window.__vibeai_canvas_debug = {
                  setActiveTone: function(tone) {
                    const validTones = ['calm', 'urgent', 'reflective', 'dissonant', 'resonant'];
                    if (!validTones.includes(tone)) {
                      console.error('[VibeAI Debug] Invalid tone. Use: ' + validTones.join(', '));
                      return;
                    }
                    const event = new CustomEvent('vibeai:setTone', { detail: { tone: tone } });
                    document.dispatchEvent(event);
                    console.log('[VibeAI Debug] Tone change requested: ' + tone);
                  },
                  getTone: function() {
                    return window.__vibeai_current_tone || 'unknown';
                  },
                  listTones: function() {
                    console.log('Available tones: calm, urgent, reflective, dissonant, resonant');
                    return ['calm', 'urgent', 'reflective', 'dissonant', 'resonant'];
                  },
                  help: function() {
                    console.log('%cüé® VibeAI Canvas Debug API', 'font-size: 14px; font-weight: bold; color: #00d4ff;');
                    console.log('');
                    console.log('Available commands:');
                    console.log('  __vibeai_canvas_debug.setActiveTone("urgent")  - Change active tone');
                    console.log('  __vibeai_canvas_debug.getTone()                 - Get current tone');
                    console.log('  __vibeai_canvas_debug.listTones()               - List all tones');
                    console.log('  __vibeai_canvas_debug.help()                    - Show this help');
                    console.log('');
                    console.log('Available tones: üåä calm, ‚ö° urgent, üîÆ reflective, ‚öôÔ∏è dissonant, ‚ú® resonant');
                  }
                };

                // Store initial tone
                window.__vibeai_current_tone = 'calm';

                console.log('%c[VibeAI Canvas] üé® Debug API Ready', 'color: #00d4ff; font-weight: bold');
                console.log('Type: __vibeai_canvas_debug.help() for usage');
              })();
            `;

            // Inject into page - use both head and documentElement for reliability
            (document.head || document.documentElement).appendChild(bridgeScript);

            // Small delay to ensure script executes, then remove
            setTimeout(() => {
              if (bridgeScript.parentNode) {
                bridgeScript.remove();
              }
              // Phase Œî9.2: Signal that debug bridge is ready
              document.dispatchEvent(new CustomEvent('vibeai:debugBridgeReady'));
            }, 100);

            // Listen for tone change events from page context
            document.addEventListener('vibeai:setTone', (event) => {
              const tone = event.detail.tone;
              if (foldSpaceCanvas && foldSpaceCanvas.setActiveTone) {
                foldSpaceCanvas.setActiveTone(tone);

                // Update current tone in page context
                const updateScript = document.createElement('script');
                updateScript.textContent = `window.__vibeai_current_tone = '${tone}';`;
                (document.head || document.documentElement).appendChild(updateScript);
                setTimeout(() => updateScript.remove(), 10);
              }
            });

            console.log('[VibeAI Canvas] Debug bridge injected (cross-context active)');
          } catch (hookErr) {
            console.warn('[VibeAI Canvas] Failed to inject debug bridge:', hookErr);
          }
        } else {
          console.log('[VibeAI] Running in production mode - debug APIs disabled');
        }

        // Phase Œî.9: Initialize with HugoScore Bridge
        if (window.VIBEAI_LAST_THREADS && window.VIBEAI_LAST_THREADS.length > 0) {
          const latest = window.VIBEAI_LAST_THREADS[window.VIBEAI_LAST_THREADS.length - 1];
          if (latest && latest.content) {
            updateHugoBridge(latest.content);
          }
        }

        // Phase Œî9.3-Lite: Listen for dynamic thread updates (every 8s from parser)
        document.addEventListener('vibeai:threadUpdate', (e) => {
          if (e.detail && e.detail.content) {
            updateHugoBridge(e.detail.content);
            console.log(`[VibeAI Œî9.3] üîÑ Canvas updated from ${e.detail.platform} (${e.detail.count} messages)`);
          }
        });
        console.log('[VibeAI Œî9.3] ‚úÖ Dynamic thread monitoring active (8s interval)');

      } catch (err) {
        console.error('[VibeAI Canvas] Failed to initialize:', err);
      }
    }
  } // End initializeFoldSpaceCanvas

  console.log('[VibeAI UniHUD] ‚úÖ Unified HUD Container injected');
  return hud;
}

// Ensure there's a foldspace canvas element available (pre-injected placeholder)
function ensureCanvasLayer() {
  try {
    if (document.getElementById('foldspace-canvas')) return;
    const canvas = document.createElement('div');
    canvas.id = 'foldspace-canvas';
    canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 2147483646; /* just under the HUD */
      display: block;
    `;
    // Keep it empty for now; real canvas will be injected later by FoldSpaceCanvas when re-integrated
    document.body.appendChild(canvas);
    console.log('[VibeAI UniHUD] ‚úÖ Pre-injected foldspace-canvas placeholder');
  } catch { /* best-effort */ }
}

/**
 * Public injector with optional MutationObserver fallback for hosts that re-render (e.g., ChatGPT)
 * options: { observer: boolean }
 */
function injectUnifiedHUD(options = { observer: true }) {
  try {
    // Prefer stable body mount to avoid React overwrites
    if (document.getElementById('vibeai-unified-hud')) {
      return document.getElementById('vibeai-unified-hud');
    }

  const hud = renderHUDContainer();

    // Only enable reinjection observer on ChatGPT by default to avoid unnecessary overhead on other platforms
    try {
      const shouldObserve = Boolean(options && options.observer) && PLATFORM === 'chatgpt';
      if (shouldObserve && !window.__vibeai_unified_observer_set) {
        const observer = new MutationObserver(() => {
          try {
            if (!document.getElementById('vibeai-unified-hud')) {
              console.warn('[VibeAI UniHUD] HUD removed from DOM ‚Äî reinjecting');
              // reinject via unified API so observer can be enabled when needed
              injectUnifiedHUD();
            }
          } catch { /* ignore */ }
        });
        observer.observe(document.body, { childList: true, subtree: true });
        window.__vibeai_unified_observer_set = true;
        window.__vibeai_unified_observer = observer;
        console.log('[VibeAI UniHUD] MutationObserver enabled for reinjection (ChatGPT)');
      }
    } catch { /* ignore observer errors */ }

    // Show first-time onboarding hint after HUD is mounted
    setTimeout(() => {
      showFirstTimeHint();
    }, 500);

    return hud;
  } catch (err) {
    console.error('[VibeAI UniHUD] injectUnifiedHUD failed', err);
    return null;
  }
}

// Expose a global for other scripts to call if module exports are not used
try { window.injectUnifiedHUD = injectUnifiedHUD; } catch { /* ignore */ }

// Global click-to-scroll handler to support Claude-style message anchors
document.addEventListener('click', (e) => {
  try {
    const item = e.target.closest('.hud-thread-item, .vibeai-thread-card');
    if (!item) return;

    // Prefer data-message-id (Claude) then fallback to data-thread-id
    const messageId = item.dataset.messageId;
    const threadId = item.getAttribute('data-thread-id') || item.dataset.threadId;

    if (messageId) {
      const target = document.querySelector(`[data-message-id="${messageId}"]`);
      if (target) {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        return;
      }
    }

    if (threadId) {
      // Delegate to existing scrollToThread logic which accepts our thread ids
      try { scrollToThread(threadId); } catch { /* ignore */ }
    }
  } catch (err) {
    console.warn('[VibeAI UniHUD] click-to-scroll handler error', err);
  }
});

// 2. Inject scoped CSS
function injectHUDStyles() {
  if (document.getElementById('vibeai-unified-hud-styles')) return;

  const style = document.createElement('style');
  style.id = 'vibeai-unified-hud-styles';
  style.textContent = `
    .vibeai-btn {
      padding: 6px 12px;
      background: rgba(0, 170, 255, 0.15);
      color: #00d4ff;
      border: 1px solid rgba(0, 170, 255, 0.3);
      border-radius: 6px;
      font-size: 0.75em;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: inherit;
    }
    .vibeai-btn:hover {
      background: rgba(0, 170, 255, 0.25);
      border-color: rgba(0, 170, 255, 0.5);
      transform: scale(1.05);
    }
    .vibeai-icon-btn {
      width: 28px;
      height: 28px;
      padding: 0;
      background: rgba(0, 170, 255, 0.15);
      color: #00d4ff;
      border: 1px solid rgba(0, 170, 255, 0.3);
      border-radius: 6px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: inherit;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .vibeai-icon-btn:hover {
      background: rgba(0, 170, 255, 0.25);
      border-color: rgba(0, 170, 255, 0.5);
      transform: scale(1.1);
    }
    .hud-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      width: 100%;
    }
    .hud-button-group {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }
    .hud-button, .reanalyze-button {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(0,170,255,0.12);
      padding: 6px 8px;
      font-size: 0.82em;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      transition: background 0.12s ease, transform 0.08s ease;
      white-space: nowrap;
    }
    .reanalyze-button {
      padding: 6px 8px;
      font-size: 0.78em;
      flex-shrink: 0;
    }
    .hud-button:hover, .reanalyze-button:hover {
      background: rgba(255,255,255,0.12);
      transform: translateY(-1px);
    }
    #vibeai-consent:hover,
    #vibeai-privacy:hover,
    #vibeai-report-bug:hover {
      opacity: 1 !important;
    }
      /* Tile icon image + emoji fallback handling */
      .foldspace-tile-icon {
        width: 28px;
        height: 28px;
        object-fit: contain;
        display: block;
      }
      .foldspace-tile-symbol {
        display: none; /* shown only when image fails (onerror toggles) */
      }
        /* Mini cluster icons + emoji fallback */
        .foldspace-mini-icon {
          width: 18px;
          height: 18px;
          object-fit: contain;
          display: inline-block;
          vertical-align: middle;
        }
        .foldspace-mini-fallback-symbol {
          display: none;
          font-size: 14px;
          line-height: 14px;
          vertical-align: middle;
        }
    .vibeai-thread-card {
      margin: 8px 0;
      padding: 12px;
      background: rgba(255, 255, 255, 0.07);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      border-left: 3px solid transparent;
    }
    .vibeai-thread-card:hover {
      background: rgba(0, 170, 255, 0.15);
      border-left-color: #00aaff;
      transform: translateX(4px);
      box-shadow: 0 4px 12px rgba(0, 170, 255, 0.2);
    }
    .vibeai-thread-card .title {
      font-weight: 600;
      font-size: 0.95em;
      margin-bottom: 6px;
      color: #fff;
    }
    .vibeai-thread-card .preview {
      font-size: 0.85em;
      opacity: 0.8;
      line-height: 1.4;
      color: #ccc;
      margin-bottom: 6px;
    }
    .vibeai-thread-card .meta {
      font-size: 0.75em;
      opacity: 0.6;
      color: #aaa;
      font-style: italic;
    }
    #vibeai-thread-feed-unified::-webkit-scrollbar {
      width: 6px;
    }
    #vibeai-thread-feed-unified::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
    }
    #vibeai-thread-feed-unified::-webkit-scrollbar-thumb {
      background: rgba(0, 170, 255, 0.3);
      border-radius: 10px;
    }
    #vibeai-thread-feed-unified::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 170, 255, 0.5);
    }

    /* üåó Theme Toggle Button */
    #vibeai-theme-toggle:hover {
      transform: scale(1.15) rotate(15deg);
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    }

    /* Coherence Pulse Animation (on theme switch) */
    @keyframes coherence-pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
    }

    .theme-switching .foldspace-tile {
      animation: coherence-pulse 0.6s ease-in-out;
    }

    /* Smooth theme transitions */
    #vibeai-unified-hud,
    .foldspace-tile,
    .vibeai-thread-card,
    .vibeai-btn {
      transition: background 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                  color 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                  box-shadow 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                  border-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
  `;
  document.head.appendChild(style);
  console.log('[VibeAI UniHUD] ‚úÖ Styles injected');
}

// 3. Event listeners
function attachEventListeners() {
  const reanalyzeBtn = document.getElementById('vibeai-reanalyze');
  const toggleCanvasBtn = document.getElementById('vibeai-toggle-canvas');
  const closeBtn = document.getElementById('vibeai-close-hud');
  const consentBtn = document.getElementById('vibeai-consent');
  const privacyBtn = document.getElementById('vibeai-privacy');
  const reportBugBtn = document.getElementById('vibeai-report-bug');
  const themeToggleBtn = document.getElementById('vibeai-theme-toggle');
  const lexiconToggleBtn = document.getElementById('vibeai-lexicon-toggle');

  if (reanalyzeBtn) {
    reanalyzeBtn.addEventListener('click', () => {
      console.log('[VibeAI UniHUD] üîÑ Reanalyze triggered');
      // Trigger re-scan
      if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
        chrome.runtime.sendMessage({ type: 'RESCAN_THREADS' });
      }
    });
  }

  if (toggleCanvasBtn) {
    let hudMinimized = false;
    toggleCanvasBtn.addEventListener('click', () => {
      const hud = document.getElementById('vibeai-unified-hud');
      if (hud) {
        hudMinimized = !hudMinimized;

        if (hudMinimized) {
          // Minimize: collapse to bottom tab
          hud.style.width = '200px';
          hud.style.height = '52px';
          hud.style.maxHeight = '52px';
          hud.style.top = 'auto';
          hud.style.bottom = '24px';
          hud.style.right = '24px';
          hud.style.transform = 'none';
          hud.style.borderRadius = '26px';
          hud.style.overflow = 'hidden';

          // Hide all content except header
          const utils = document.getElementById('vibeai-utils');
          const canvas = document.getElementById('vibeai-foldspace-header');
          const threadFeed = document.getElementById('vibeai-thread-feed-unified');
          const footer = document.getElementById('vibeai-hud-footer');
          const headerTitle = document.getElementById('vibeai-header-title');
          const closeBtn = document.getElementById('vibeai-close-hud');

          if (utils) utils.style.display = 'none';
          if (canvas) canvas.style.display = 'none';
          if (threadFeed) threadFeed.style.display = 'none';
          if (footer) footer.style.display = 'none';
          if (closeBtn) closeBtn.style.display = 'none';

          // Show "VibeAI" text in minimized mode
          if (headerTitle) {
            headerTitle.style.display = 'block';
            headerTitle.style.flex = '1';
            headerTitle.style.textAlign = 'left';
            headerTitle.innerHTML = '<div style="font-size: 0.95em; font-weight: bold; color: #00d4ff; letter-spacing: 1px;">VibeAI</div>';
          }

          toggleCanvasBtn.textContent = '‚ñ°';
          toggleCanvasBtn.style.fontSize = '20px';
          toggleCanvasBtn.style.background = 'rgba(0, 170, 255, 0.3)';
          toggleCanvasBtn.style.color = '#00d4ff';
          toggleCanvasBtn.title = 'Maximize HUD';
          console.log('[VibeAI UniHUD] HUD minimized to bottom tab');
        } else {
          // Maximize: restore full HUD
          hud.style.width = '360px';
          hud.style.height = 'auto';
          hud.style.maxHeight = '85vh';
          hud.style.top = '50%';
          hud.style.bottom = 'auto';
          hud.style.right = '20px';
          hud.style.transform = 'translateY(-50%)';
          hud.style.borderRadius = '16px';
          hud.style.overflow = 'visible';

          // Show all content
          const utils = document.getElementById('vibeai-utils');
          const canvas = document.getElementById('vibeai-foldspace-header');
          const threadFeed = document.getElementById('vibeai-thread-feed-unified');
          const footer = document.getElementById('vibeai-hud-footer');
          const headerTitle = document.getElementById('vibeai-header-title');
          const closeBtn = document.getElementById('vibeai-close-hud');

          if (utils) utils.style.display = 'flex';
          if (canvas) canvas.style.display = 'flex';
          if (threadFeed) threadFeed.style.display = 'block';
          if (footer) footer.style.display = 'flex';
          if (closeBtn) closeBtn.style.display = 'block';

          // Restore original title
          if (headerTitle) {
            headerTitle.style.display = 'block';
            headerTitle.style.flex = '1';
            headerTitle.style.textAlign = 'center';
            headerTitle.innerHTML = '<div style="font-size: 1.15em; font-weight: bold; color: #00d4ff; letter-spacing: 1.5px;">VibeAI Thread Inspector</div>';
          }

          toggleCanvasBtn.textContent = '‚Äî';
          toggleCanvasBtn.style.fontSize = '18px';
          toggleCanvasBtn.style.background = '';
          toggleCanvasBtn.style.color = '';
          toggleCanvasBtn.title = 'Minimize HUD';
          console.log('[VibeAI UniHUD] HUD maximized');
        }
      }
    });
  }

  if (closeBtn) {
    closeBtn.addEventListener('click', () => {
      const hud = document.getElementById('vibeai-unified-hud');
      if (hud) {
        hud.style.display = 'none';
        console.log('[VibeAI UniHUD] HUD hidden');

        // üé® Phase Œî.8 - Cleanup canvas on close
        if (foldSpaceCanvas) {
          foldSpaceCanvas.destroy();
          foldSpaceCanvas = null;
        }
      }
    });
  }

  if (consentBtn) {
    consentBtn.addEventListener('click', () => {
      console.log('[VibeAI UniHUD] üìã Consent clicked - showing consent modal');
      showConsentModal();
    });
  }

  if (privacyBtn) {
    privacyBtn.addEventListener('click', () => {
      console.log('[VibeAI UniHUD] üîí Privacy clicked - opening privacy statement');
      showPrivacyModal();
    });
  }

  if (reportBugBtn) {
    reportBugBtn.addEventListener('click', () => {
      console.log('[VibeAI UniHUD] üêõ Report Bug clicked');
      window.open('https://github.com/TNL-Origin/vibeai-foldspace/issues/new?template=bug_report.md', '_blank');
    });
  }

  // Theme toggle button
  if (themeToggleBtn) {
    themeToggleBtn.addEventListener('click', () => {
      toggleTheme();
      // Update button icon
      themeToggleBtn.textContent = currentTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
      themeToggleBtn.title = `Switch to ${currentTheme === 'dark' ? 'light' : 'dark'} mode`;
    });
  }

  // Phase Œî.9.1: Lexicon toggle button (Youth ‚Üî Pro)
  if (lexiconToggleBtn) {
    lexiconToggleBtn.addEventListener('click', async () => {
      const newLexicon = ACTIVE_LEXICON === 'youth' ? 'pro' : 'youth';
      const success = await switchLexicon(newLexicon);

      if (success) {
        // Update button icon and title
        lexiconToggleBtn.textContent = ACTIVE_LEXICON === 'youth' ? 'üéì' : 'üíº';
        lexiconToggleBtn.title = `Toggle lexicon (Current: ${ACTIVE_LEXICON})`;
        console.log(`[VibeAI Lexicon] üîÑ UI switched to ${ACTIVE_LEXICON} mode`);
      } else {
        console.error('[VibeAI Lexicon] ‚ùå Failed to switch lexicon');
      }
    });
  }

  // Opacity slider
  const opacitySlider = document.getElementById('vibeai-opacity-slider');
  if (opacitySlider) {
    // Load saved opacity value
    try {
      chrome.storage.local.get('vibeaiOpacity').then(result => {
        const savedOpacity = result.vibeaiOpacity || 0.12;
        opacitySlider.value = savedOpacity;
        document.documentElement.style.setProperty('--vibeai-hud-opacity', savedOpacity);
      }).catch(() => {
        // Fallback if storage fails
        document.documentElement.style.setProperty('--vibeai-hud-opacity', 0.12);
      });
    } catch {
      document.documentElement.style.setProperty('--vibeai-hud-opacity', 0.12);
    }

    // Listen for opacity changes
    opacitySlider.addEventListener('input', (e) => {
      const opacity = parseFloat(e.target.value);
      document.documentElement.style.setProperty('--vibeai-hud-opacity', opacity);
      console.log(`[VibeAI UniHUD] ü´ß Opacity set to ${(opacity * 100).toFixed(0)}%`);
    });

    // Save on change (after user stops dragging)
    opacitySlider.addEventListener('change', (e) => {
      const opacity = parseFloat(e.target.value);
      try {
        chrome.storage.local.set({ vibeaiOpacity: opacity });
        console.log(`[VibeAI UniHUD] ‚úÖ Opacity ${(opacity * 100).toFixed(0)}% saved`);
      } catch (err) {
        console.log('[VibeAI UniHUD] Could not save opacity preference:', err);
      }
    });
  }
}

// 4. Update thread feed
function updateThreadFeed(threads) {
  const feedEl = document.getElementById('vibeai-thread-feed-unified');
  if (!feedEl) return;

  if (!threads || threads.length === 0) {
    feedEl.innerHTML = `<p style="text-align: center; color: #999; padding: 30px 20px; font-style: italic;">üß† No threads detected yet. <br><small style="display: block; margin-top: 8px; font-size: 0.9em; opacity: 0.6;">Start chatting to see AI-analyzed threads appear here.</small></p>`;
    return;
  }

  // Phase Œî.9: Update HugoScore Bridge with latest thread
  if (threads.length > 0) {
    const latest = threads[threads.length - 1];
    if (latest && latest.content) {
      updateHugoBridge(latest.content);
    }
  }

  // Helper to render a small FoldSpace mini-canvas showing 1..N mood glyphs for the thread.
  // We intentionally omit textual labels (Resonant/Tense/etc.) to keep the UI visual-only per spec.
  function foldspaceMiniHTML(thread, maxEmojis = 5) {
    // Prefer an explicit emotionalTones array if present: e.g. ['calm','urgent','resonant']
    const tones = Array.isArray(thread.emotionalTones) && thread.emotionalTones.length > 0
      ? thread.emotionalTones.slice(0, maxEmojis)
      : null;

    const hugoScore = Number(thread.hugoScore ?? thread.score ?? NaN);
    const evc = Number(thread.evc ?? NaN);
    const hsvi = Number(thread.hsvi ?? NaN);
    const tag = (thread.tag || thread.source || '').toLowerCase();

    const pickFromMetrics = () => {
      const out = [];
      if (!Number.isNaN(hugoScore)) {
        if (hugoScore >= 85) out.push('resonant');
        else if (hugoScore >= 60) out.push('calm');
        else out.push('drift');
      }
      if (!Number.isNaN(hsvi) && hsvi >= 50) out.push('tense');
      if (!Number.isNaN(evc) && evc < 0.3) out.push('dissonant');
      if (tag) out.push(tag);
      return out.slice(0, maxEmojis);
    };

    const mapped = tones || pickFromMetrics();

    // Map mood keys to representative emoji (these can be replaced with image assets later)
    const moodMap = {
      resonant: 'üåä',
      calm: 'üíß',
      drift: 'üå´Ô∏è',
      tense: '‚ö°',
      urgent: 'üî•',
      reflective: 'ü™û',
      dissonant: 'üî∂',
      default: 'üåå'
    };

    const emojis = (mapped && mapped.length) ? mapped : ['default'];

    const containerStyle = 'display:inline-flex;flex-wrap:wrap;gap:6px;align-items:center;justify-content:center;width:68px;height:48px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));padding:6px;margin-right:8px;flex:0 0 auto;';

    // Render up to maxEmojis as a small cluster of native emoji (CSP-safe, no img fallback)
    const items = (emojis.slice(0, maxEmojis)).map(k => {
      const key = (k || 'default').toLowerCase();
      const emoji = moodMap[key] || moodMap.default;
      return `<span class="foldspace-mini-emoji" role="img" aria-label="${key}" ` +
               `style="display:inline-flex;align-items:center;justify-content:center;` +
               `font-size:20px;width:24px;height:24px;` +
               `text-shadow:0 1px 3px rgba(0,0,0,0.3);` +
               `filter:drop-shadow(0 1px 2px rgba(0,0,0,0.25));` +
               `transition:transform 0.2s ease;">` +
               `${emoji}</span>`;
    }).join('');

    return `<div class="foldspace-mini" title="Mood" style="${containerStyle}">${items}</div>`;
  }

  feedEl.innerHTML = threads.map(t => {
    // SECURITY: Escape all user-sourced content to prevent XSS
    const rawTitle = t.title || autoTitle(t.content);
    const rawPreview = (t.content || '').slice(0, 100);
    const rawSource = t.source || 'unknown';
    const rawThreadId = t.id || '';
    const rawTimestamp = t.timestamp ? new Date(t.timestamp).toLocaleTimeString() : '';

    const title = escapeHtml(rawTitle);
    const preview = escapeHtml(rawPreview);
    const source = escapeHtml(rawSource);
    const threadId = escapeHtml(rawThreadId);
    const timestamp = escapeHtml(rawTimestamp);

    const foldMini = foldspaceMiniHTML(t, 5);

    return `<div class='vibeai-thread-card' data-thread-id='${threadId}' style='cursor: pointer; display:flex; gap:8px; align-items:flex-start;'>
              ${foldMini}
              <div style='flex:1'>
                <div class='title'>${title}</div>
                <div class='preview'>${preview}‚Ä¶</div>
                <div class='meta'>${source} ‚Ä¢ ${timestamp}</div>
              </div>
            </div>`;
  }).join('');

  // Add click-to-scroll event listeners
  feedEl.querySelectorAll('.vibeai-thread-card').forEach(card => {
    card.addEventListener('click', () => {
      const threadId = card.getAttribute('data-thread-id');
      scrollToThread(threadId);
    });
  });

  console.log(`[VibeAI UniHUD] ‚úÖ Rendered ${threads.length} threads`);
}

// Helper: auto-title from first 5 words
function autoTitle(content) {
  if (!content) return 'Untitled Thread';
  const words = content.trim().split(/\s+/).slice(0, 5);
  return words.join(' ') + (content.split(/\s+/).length > 5 ? '...' : '');
}

// Scroll to thread on click
function scrollToThread(threadId) {
  console.log(`[VibeAI UniHUD] üéØ Scrolling to thread: ${threadId}`);

  // Detect platform
  const _HOSTNAME = window.location.hostname;
  const platform = threadId.split('-')[0];

  // Extract index from thread ID (format: "platform-index")
  const match = threadId.match(/-(\d+)$/);
  if (!match) {
    console.warn(`[VibeAI UniHUD] ‚ö†Ô∏è Invalid thread ID format: ${threadId}`);
    return;
  }

  const index = parseInt(match[1], 10);
  let targetElement = null;

  // Get the corresponding DOM node based on platform
  if (platform === 'chatgpt') {
    const nodes = document.querySelectorAll('.markdown, .text-base');
    targetElement = nodes[index];
  } else if (platform === 'gemini') {
    const nodes = document.querySelectorAll('[data-message-content], article, .response-container');
    targetElement = nodes[index];
  } else if (platform === 'copilot') {
    const nodes = document.querySelectorAll(
      '.ac-textBlock, .cib-message-content, [class*="message"], [class*="response-message"], [data-content], .text-message-content'
    );
    targetElement = nodes[index];
  } else if (platform === 'claude') {
    // Use centralized selector list for easier updates
    const nodes = document.querySelectorAll(CLAUDE_SELECTORS.join(', '));
    targetElement = nodes[index];
  }

  if (targetElement) {
    // Scroll to element
    targetElement.scrollIntoView({
      behavior: 'smooth',
      block: 'center',
      inline: 'nearest'
    });

    // Add highlight effect
    targetElement.style.setProperty('outline', '3px solid #00d4ff', 'important');
    targetElement.style.setProperty('background-color', 'rgba(0, 212, 255, 0.1)', 'important');
    targetElement.style.setProperty('border-radius', '8px', 'important');
    targetElement.style.setProperty('transition', 'all 0.3s ease', 'important');

    console.log(`[VibeAI UniHUD] ‚úÖ Scrolled to thread: ${threadId}`);

    // Remove highlight after 2 seconds
    setTimeout(() => {
      targetElement.style.removeProperty('outline');
      targetElement.style.removeProperty('background-color');
      targetElement.style.removeProperty('border-radius');
      console.log(`[VibeAI UniHUD] üåä Highlight faded: ${threadId}`);
    }, 2000);
  } else {
    console.warn(`[VibeAI UniHUD] ‚ö†Ô∏è Thread element not found: ${threadId} (index: ${index})`);
  }
}

// 5. Listen to storage changes (guarded for non-extension environments)
if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.onChanged) {
  chrome.storage.onChanged.addListener((changes) => {
    if (changes.lastThreads && changes.lastThreads.newValue) {
      updateThreadFeed(changes.lastThreads.newValue);
    }
  });
}

// 5.5 First-Time Onboarding Hint
function showFirstTimeHint() {
  try {
    if (!chrome || !chrome.storage || !chrome.storage.local) {
      console.warn('[VibeAI] chrome.storage.local not available for first-time hint.');
      return;
    }
  } catch (e) {
    console.warn('[VibeAI] chrome.storage.local check failed:', e);
    return;
  }

  chrome.storage.local.get('vibeai_seen_onboard_tip', (res) => {
    if (res && res.vibeai_seen_onboard_tip) {
      // Hint already shown once, do nothing
      return;
    }

    // Make sure HUD exists before attaching hint
    const hudRoot = document.getElementById('vibeai-unified-hud');
    if (!hudRoot) {
      console.warn('[VibeAI] HUD root not found, cannot show first-time hint.');
      return;
    }

    // Create popover container
    const hint = document.createElement('div');
    hint.id = 'vibeai-first-time-hint';
    hint.style.cssText = `
      position: fixed;
      top: 50%;
      right: 400px;
      transform: translateY(-50%);
      z-index: 2147483646;
      max-width: 280px;
      background: linear-gradient(135deg, #1f2933 0%, #111827 40%, #0f766e 100%);
      color: #f9fafb;
      padding: 16px 18px;
      border-radius: 14px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.55);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 13px;
      line-height: 1.5;
      border: 1px solid rgba(34, 211, 238, 0.55);
      backdrop-filter: blur(10px);
      animation: vibeai-slide-in 0.25s ease-out;
    `;

    hint.innerHTML = `
      <div style="font-size: 15px; font-weight: 600; margin-bottom: 6px; display: flex; align-items: center; gap: 6px;">
        <span style="font-size: 18px;">üëã</span>
        <span>Welcome to the FoldSpace Canvas</span>
      </div>
      <div style="margin-bottom: 10px;">
        This canvas visualizes the conversation's emotional weather. Send a message in the chat and watch colors, glyphs, and pulses change. Click any thread on the right to jump to that message.
      </div>
      <button id="vibeai-first-time-hint-btn"
        style="
          width: 100%;
          margin-top: 4px;
          padding: 7px 10px;
          border-radius: 999px;
          border: 1px solid rgba(148, 163, 184, 0.7);
          background: rgba(15, 23, 42, 0.6);
          color: #e5e7eb;
          font-size: 13px;
          cursor: pointer;
        ">
        Got it
      </button>
    `;

    // Append to body (not inside HUD so it floats nearby)
    document.body.appendChild(hint);

    function dismissHint() {
      chrome.storage.local.set({ vibeai_seen_onboard_tip: true }, () => {
        const el = document.getElementById('vibeai-first-time-hint');
        if (el && el.parentElement) {
          el.parentElement.removeChild(el);
        }
      });
    }

    const btn = document.getElementById('vibeai-first-time-hint-btn');
    if (btn) {
      btn.addEventListener('click', dismissHint);
    }

    // Auto-dismiss after 12 seconds if user ignores it
    setTimeout(() => {
      const stillVisible = document.getElementById('vibeai-first-time-hint');
      if (stillVisible) {
        dismissHint();
      }
    }, 12000);
  });
}

// Optional: simple keyframes for the slide-in animation
try {
  const styleId = 'vibeai-first-time-hint-anim-style';
  if (!document.getElementById(styleId)) {
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      @keyframes vibeai-slide-in {
        from {
          opacity: 0;
          transform: translateY(-50%) translateX(12px);
        }
        to {
          opacity: 1;
          transform: translateY(-50%) translateX(0);
        }
      }
    `;
    document.head.appendChild(style);
  }
} catch (e) {
  console.warn('[VibeAI] Could not inject first-time hint animation style:', e);
}

// 6. Consent Modal
function showConsentModal() {
  if (document.getElementById('vibeai-consent-modal')) return;

  const modal = document.createElement('div');
  modal.id = 'vibeai-consent-modal';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    z-index: 2147483648;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
  `;

  modal.innerHTML = `
    <div style="
      background: rgba(15, 15, 20, 0.95);
      border: 2px solid rgba(0, 212, 255, 0.5);
      border-radius: 16px;
      padding: 32px 40px;
      max-width: 500px;
      box-shadow: 0 0 50px rgba(0, 170, 255, 0.6);
      color: #fff;
    ">
      <div style="font-size: 1.6em; font-weight: bold; color: #00d4ff; letter-spacing: 2px; margin-bottom: 12px; text-align: center;">
        VibeAI FoldSpace
      </div>
      <div style="font-size: 0.95em; color: rgba(0, 212, 255, 0.8); text-align: center; margin-bottom: 24px;">
        Thread Inspector & Emotional Tone Analyzer
      </div>
      <div style="font-size: 0.9em; line-height: 1.6; color: #ccc; margin-bottom: 24px;">
        <p style="margin-bottom: 12px;">
          VibeAI analyzes conversational threads on this page to detect emotional tone and resonance patterns.
        </p>
        <p style="margin-bottom: 12px;">
          <strong style="color: #00d4ff;">This extension:</strong>
        </p>
        <ul style="margin-left: 20px; margin-bottom: 12px;">
          <li>Reads chat messages on this page only</li>
          <li>Analyzes emotional tone (HugoScore)</li>
          <li>Stores analysis locally in your browser</li>
          <li>Never sends data to external servers</li>
        </ul>
        <p style="font-size: 0.85em; opacity: 0.7; font-style: italic;">
          All processing happens locally. Your privacy is protected.
        </p>
      </div>
      <div style="display: flex; gap: 12px; justify-content: center;">
        <button id="vibeai-consent-accept" style="
          padding: 10px 24px;
          background: rgba(0, 170, 255, 0.3);
          color: #00d4ff;
          border: 2px solid rgba(0, 170, 255, 0.5);
          border-radius: 8px;
          font-size: 1em;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s ease;
        ">Accept & Continue</button>
        <button id="vibeai-consent-decline" style="
          padding: 10px 24px;
          background: rgba(255, 79, 79, 0.2);
          color: #ff4f4f;
          border: 2px solid rgba(255, 79, 79, 0.4);
          border-radius: 8px;
          font-size: 1em;
          cursor: pointer;
          transition: all 0.2s ease;
        ">Decline</button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // Accept button
    document.getElementById('vibeai-consent-accept').addEventListener('click', () => {
    if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
      chrome.storage.local.set({ consentGiven: true }, () => {
        console.log('[VibeAI UniHUD] ‚úÖ User consent granted');
        modal.remove();
        renderHUDContainer();
      });
    } else {
      // Fallback for non-extension envs
  try { localStorage.setItem('vibeai_consentGiven', 'true'); } catch (e) { console.warn('[VibeAI UniHUD] local fallback set failed', e); }
      console.log('[VibeAI UniHUD] ‚úÖ User consent granted (local fallback)');
      modal.remove();
      renderHUDContainer();
    }
  });

  // Decline button
  document.getElementById('vibeai-consent-decline').addEventListener('click', () => {
    if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
      chrome.storage.local.set({ consentGiven: false }, () => {
        console.log('[VibeAI UniHUD] ‚ùå User declined consent');
        modal.remove();
      });
    } else {
  try { localStorage.setItem('vibeai_consentGiven', 'false'); } catch (e) { console.warn('[VibeAI UniHUD] local fallback set failed', e); }
      console.log('[VibeAI UniHUD] ‚ùå User declined consent (local fallback)');
      modal.remove();
    }
  });

  console.log('[VibeAI UniHUD] üìã Consent modal displayed');
}

// 6b. Privacy Modal
function showPrivacyModal() {
  if (document.getElementById('vibeai-privacy-modal')) return;

  const modal = document.createElement('div');
  modal.id = 'vibeai-privacy-modal';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    z-index: 2147483648;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
  `;

  modal.innerHTML = `
    <div style="
      background: rgba(15, 15, 20, 0.95);
      border: 2px solid rgba(0, 212, 255, 0.5);
      border-radius: 16px;
      padding: 32px 40px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 0 50px rgba(0, 170, 255, 0.6);
      color: #fff;
    ">
      <div style="font-size: 1.6em; font-weight: bold; color: #00d4ff; letter-spacing: 2px; margin-bottom: 12px; text-align: center;">
        üîí Privacy Statement
      </div>
      <div style="font-size: 0.95em; color: rgba(0, 212, 255, 0.8); text-align: center; margin-bottom: 24px;">
        VibeAI FoldSpace Extension
      </div>
      <div style="font-size: 0.9em; line-height: 1.6; color: #ccc; margin-bottom: 24px;">
        <h3 style="color: #00d4ff; margin-top: 16px; margin-bottom: 12px;">Data Collection</h3>
        <p style="margin-bottom: 12px;">
          VibeAI FoldSpace <strong>does not collect, transmit, or store any personal data on external servers</strong>.
          All analysis happens locally in your browser.
        </p>

        <h3 style="color: #00d4ff; margin-top: 16px; margin-bottom: 12px;">What We Process</h3>
        <ul style="margin-left: 20px; margin-bottom: 12px;">
          <li>Chat thread messages visible on the current page</li>
          <li>Emotional tone analysis (HugoScore algorithm)</li>
          <li>Thread metadata (timestamps, platform detection)</li>
        </ul>

        <h3 style="color: #00d4ff; margin-top: 16px; margin-bottom: 12px;">Local Storage Only</h3>
        <p style="margin-bottom: 12px;">
          All processed data is stored using Chrome's <code style="background: rgba(0, 170, 255, 0.2); padding: 2px 6px; border-radius: 4px;">chrome.storage.local</code> API,
          which remains on your device and is never synchronized or uploaded.
        </p>

        <h3 style="color: #00d4ff; margin-top: 16px; margin-bottom: 12px;">Third-Party Access</h3>
        <p style="margin-bottom: 12px;">
          This extension <strong>does not communicate with any external APIs or servers</strong>.
          No analytics, tracking, or telemetry is performed.
        </p>

        <h3 style="color: #00d4ff; margin-top: 16px; margin-bottom: 12px;">Open Source</h3>
        <p style="margin-bottom: 12px;">
          You can review the complete source code at:
          <a href="https://github.com/TNL-Origin/vibeai-foldspace" target="_blank" style="color: #00d4ff; text-decoration: underline;">
            github.com/TNL-Origin/vibeai-foldspace
          </a>
        </p>

        <p style="font-size: 0.85em; opacity: 0.7; font-style: italic; margin-top: 20px;">
          Last updated: January 2025
        </p>
      </div>
      <div style="display: flex; justify-content: center;">
        <button id="vibeai-privacy-close" style="
          padding: 10px 24px;
          background: rgba(0, 170, 255, 0.3);
          color: #00d4ff;
          border: 2px solid rgba(0, 170, 255, 0.5);
          border-radius: 8px;
          font-size: 1em;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s ease;
        ">Close</button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // Close button
  document.getElementById('vibeai-privacy-close').addEventListener('click', () => {
    modal.remove();
    console.log('[VibeAI UniHUD] üîí Privacy modal closed');
  });

  // Click outside to close
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.remove();
    }
  });

  console.log('[VibeAI UniHUD] üîí Privacy modal displayed');
}

// 7. Initial load (guarded)
if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local && chrome.storage.local.get) {
  chrome.storage.local.get(['lastThreads'], (data) => {
    if (data && data.lastThreads) {
      updateThreadFeed(data.lastThreads);
    }
  });
} else {
  // Local fallback (best-effort)
  try {
    const raw = localStorage.getItem('vibeai_lastThreads');
    if (raw) updateThreadFeed(JSON.parse(raw));
  } catch { /* ignore */ }
}

// 8. Robust initialization window with consent check + fallback reinjection for ChatGPT
function vibeaiSafeInit() {
  try {
    chrome.storage.local.get(['consentGiven'], (data) => {
      if (data.consentGiven === true) {
        // Small delay to avoid race with hydrations; enable observer only on ChatGPT
        setTimeout(() => injectUnifiedHUD({ observer: PLATFORM === 'chatgpt' }), 1000);

        // Extra lightweight reinjection loop for hosts that aggressively wipe the DOM (ChatGPT)
        if (PLATFORM === 'chatgpt' && !window.__vibeai_unified_reinject_interval) {
          let attempts = 0;
          window.__vibeai_unified_reinject_interval = setInterval(() => {
            try {
              if (document.getElementById('vibeai-unified-hud')) {
                clearInterval(window.__vibeai_unified_reinject_interval);
                window.__vibeai_unified_reinject_interval = null;
                return;
              }
              attempts += 1;
              if (attempts > 12) { // ~18s of attempts
                clearInterval(window.__vibeai_unified_reinject_interval);
                window.__vibeai_unified_reinject_interval = null;
                return;
              }
              console.warn('[VibeAI UniHUD] Reinjection poll: HUD missing, attempting inject (ChatGPT)');
              injectUnifiedHUD({ observer: true });
            } catch { /* ignore */ }
          }, 1500);
        }

      } else if (data.consentGiven === undefined) {
        // First time - show consent modal after a short pause so hydration can finish
        setTimeout(() => {
          showConsentModal();
        }, 1000);
      }
      // If false, do nothing (user declined)
    });
  } catch (err) {
    console.warn('[VibeAI UniHUD] vibeaiSafeInit storage check failed', err);
    // Best-effort: if chrome.storage fails, fall back to immediate injection
    setTimeout(() => injectUnifiedHUD({ observer: PLATFORM === 'chatgpt' }), 1000);
  }
}

if (document.readyState === 'complete') {
  // Page already loaded
  vibeaiSafeInit();
} else {
  // Listen for the full load event (includes subresources and hydration in many apps)
  window.addEventListener('load', vibeaiSafeInit);
  // And a fallback in case load never fires or hydration is delayed
  setTimeout(vibeaiSafeInit, 3000);
}
