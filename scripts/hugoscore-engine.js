/**
 * VibeAI Resonance Engine V2.1 - Supreme Council Synthesis
 * Integrates best practices from Chamlin, Gemini, and Copilot research
 *
 * Research Foundation:
 * - VADER (Hutto & Gilbert, 2014): Intensity boosters + negation
 * - Circumplex Model (Russell, 1980): Valence + arousal dimensions
 * - GoEmotions (Google, 2020): Fine-grained emotion taxonomy
 * - WHO/AI-Now: Crisis detection ethical frameworks
 *
 * Size: ~3.5 KB minified | CSP-compliant | Privacy-first | Offline-only
 *
 * Generated by: Claude (Supreme Council Synthesis)
 *
 * Note: Uses HRI (Hugo Resonance Index) scale 0.0-1.0 internally
 * Maintains backward compatibility with legacy HugoScore (0-100)
 */

// ═══════════════════════════════════════════════════════════
// CORE LEXICON (Manually curated, intensity-weighted)
// ═══════════════════════════════════════════════════════════

const LEX = {
  // Positive markers (weighted by intensity)
  p3: "love amazing excellent wonderful brilliant perfect incredible magnificent".split(" "),
  p2: "great good happy joy pleased nice excited delighted grateful appreciate".split(" "),
  p1: "okay fine pleasant decent fair thanks calm peace".split(" "),

  // Negative markers (weighted by intensity)
  n3: "hate terrible awful worst horrible disgusting furious devastated miserable".split(" "),
  n2: "bad angry sad upset frustrated annoyed worried disappointed unhappy fear".split(" "),
  n1: "meh blah tired bored confused concerned unsure".split(" "),

  // Crisis indicators (two-stage detection)
  c1: "suicide kill harm hurt hopeless helpless trapped worthless".split(" "),
  c2: "die death end giving up can't go on no point want out".split(" ").join(" "),

  // Contextual modifiers
  neg: ["not","no","never","neither","nobody","nothing","hardly","barely","don't","doesn't","didn't","won't","can't","isn't","aren't","wasn't","weren't"],
  boost: {very:1.5,extremely:2,incredibly:2,absolutely:1.8,really:1.3,quite:1.2,so:1.3,too:1.3,totally:1.5},
  damp: {slightly:0.7,somewhat:0.8,barely:0.5,hardly:0.5,almost:0.8},

  // Reflective/contemplative markers
  reflect: "think perhaps maybe consider wonder might could possibly interesting curious question suppose imagine believe feel seems".split(" ")
};

// ═══════════════════════════════════════════════════════════
// TOKENIZATION (Copilot-inspired efficiency)
// ═══════════════════════════════════════════════════════════

function tokenize(text) {
  return (text || "")
    .toLowerCase()
    .replace(/[^\p{L}\p{N}!?.' ]/gu, " ") // Preserve punctuation
    .split(/\s+/)
    .filter(Boolean);
}

// ═══════════════════════════════════════════════════════════
// CORE ANALYSIS ENGINE
// ═══════════════════════════════════════════════════════════

export function analyzeText(text = "") {
  if (!text || text.trim().length === 0) {
    return createEmptyResult();
  }

  const raw = text.trim();
  const words = tokenize(raw);
  const wCount = words.length;
  const unique = new Set(words).size;

  // Sentiment scoring state
  let score = 0;
  let pCount = 0; // Positive token count
  let nCount = 0; // Negative token count
  let arousal = 0; // Emotional intensity (circumplex model)
  let rCount = 0;  // Reflective token count

  // Crisis detection state
  let c1Hits = 0; // Stage 1 crisis tokens
  let c2Match = false; // Stage 2 crisis phrase

  // Context window for modifiers
  let nextBoost = 1.0;
  let negScope = 0; // Negation affects next N tokens

  // ─────────────────────────────────────────────────────────
  // Token-by-token scoring with context awareness
  // ─────────────────────────────────────────────────────────

  for (let i = 0; i < words.length; i++) {
    const w = words[i];

    // Check for modifiers (affect next token)
    if (LEX.neg.includes(w)) {
      negScope = 3; // Negation scope: next 3 tokens
      continue;
    }

    if (LEX.boost[w]) {
      nextBoost = LEX.boost[w];
      continue;
    }

    if (LEX.damp[w]) {
      nextBoost = LEX.damp[w];
      continue;
    }

    // Reflective markers
    if (LEX.reflect.includes(w)) {
      rCount++;
    }

    // Crisis detection (Stage 1: keywords)
    if (LEX.c1.includes(w)) {
      c1Hits++;
      arousal += 2.0;
    }

    // Sentiment scoring with context
    let wScore = 0;
    let wArousal = 0;

    if (LEX.p3.includes(w)) { wScore = 3; wArousal = 1.8; pCount++; }
    else if (LEX.p2.includes(w)) { wScore = 2; wArousal = 1.2; pCount++; }
    else if (LEX.p1.includes(w)) { wScore = 1; wArousal = 0.6; pCount++; }
    else if (LEX.n3.includes(w)) { wScore = -3; wArousal = 2.0; nCount++; }
    else if (LEX.n2.includes(w)) { wScore = -2; wArousal = 1.5; nCount++; }
    else if (LEX.n1.includes(w)) { wScore = -1; wArousal = 0.8; nCount++; }

    // Apply modifiers
    if (wScore !== 0) {
      wScore *= nextBoost;

      // Apply negation (reverses polarity)
      if (negScope > 0) {
        wScore *= -1;
        negScope--;
      }

      // Copilot's bias clamp: prevent single token domination
      wScore = Math.max(-4, Math.min(4, wScore));

      score += wScore;
      arousal += wArousal * Math.abs(nextBoost);

      // Reset boost
      nextBoost = 1.0;
    }

    // Decay negation scope
    if (negScope > 0 && wScore === 0) negScope--;
  }

  // Crisis detection (Stage 2: phrase matching)
  if (LEX.c2.split(" ").some(phrase => raw.includes(phrase))) {
    c2Match = true;
    arousal += 3.0;
  }

  // ─────────────────────────────────────────────────────────
  // Punctuation analysis (VADER-inspired)
  // ─────────────────────────────────────────────────────────

  const exclaim = (raw.match(/!/g) || []).length;
  const allCaps = raw === raw.toUpperCase() && wCount > 2;

  if (exclaim > 0) {
    score *= (1 + exclaim * 0.15);
    arousal += exclaim * 3;
  }

  if (allCaps) {
    arousal += 15;
  }

  // ─────────────────────────────────────────────────────────
  // Derived metrics
  // ─────────────────────────────────────────────────────────

  // Normalize sentiment (-100 to 100)
  const sentiment = Math.round(Math.max(-100, Math.min(100, (score / Math.sqrt(wCount)) * 20)));

  // Coherence (Gemini's lexical diversity + sentiment stability)
  const diversity = unique / wCount; // 0-1
  const balance = 1 - Math.abs(pCount - nCount) / Math.max(pCount + nCount, 1); // 0-1
  const coherence = Math.round(
    (diversity * 40) + // Lexical richness
    (balance * 30) +   // Emotional balance
    (wCount > 5 && wCount < 150 ? 30 : 20) // Optimal length bonus
  );

  // Resonance (Gemini): mixed emotion complexity
  const resonance = (pCount > 0 && nCount > 0)
    ? Math.round(Math.min(pCount, nCount) / Math.max(pCount, nCount) * 100)
    : 0;

  // Arousal normalization (0-100)
  arousal = Math.min(100, Math.round((arousal / wCount) * 30));

  // Valence (circumplex x-axis: -100 to 100)
  const valence = sentiment;

  // ─────────────────────────────────────────────────────────
  // Crisis triage (all three AIs' frameworks synthesized)
  // ─────────────────────────────────────────────────────────

  let crisis = "safe";
  let crisisConfidence = 0;

  if (c2Match && c1Hits >= 1) {
    crisis = "risk";
    crisisConfidence = 90;
  } else if (c1Hits >= 2) {
    crisis = "risk";
    crisisConfidence = 85;
  } else if (c1Hits === 1 && (sentiment < -40 || arousal > 70)) {
    crisis = "uncertain";
    crisisConfidence = 60;
  } else if (c2Match) {
    crisis = "uncertain";
    crisisConfidence = 55;
  }

  // ─────────────────────────────────────────────────────────
  // Confidence scoring (Chamlin's transparency principle)
  // ─────────────────────────────────────────────────────────

  let confidence = 100;

  if (wCount < 3) confidence *= 0.5;
  if (wCount > 150) confidence *= 0.85;
  if (resonance > 60) confidence *= 0.8; // Mixed emotions harder to classify
  if (c2Match && !LEX.c1.some(w => words.includes(w))) confidence *= 0.7; // Phrase without keywords

  confidence = Math.round(confidence);

  // ─────────────────────────────────────────────────────────
  // Tone and mood classification
  // ─────────────────────────────────────────────────────────

  let tone = "neutral";
  if (sentiment > 15) tone = "positive";
  else if (sentiment < -15) tone = "negative";

  const mood = determineMood(sentiment, coherence, arousal, resonance, rCount, crisis);

  // HSV color mapping (for visual glyph)
  const hsv = calculateHSV(valence, arousal, coherence);

  // ─────────────────────────────────────────────────────────
  // HRI (Hugo Resonance Index) calculation (0.0-1.0 scale)
  // ─────────────────────────────────────────────────────────

  // Calculate HRI from sentiment, coherence, and arousal
  // Normalizes to 0.0-1.0 where higher values indicate better resonance
  let hri = 0.5; // Default neutral

  // Base calculation: blend of sentiment and coherence
  const sentimentNorm = (sentiment + 100) / 200; // Convert -100..100 to 0..1
  const coherenceNorm = coherence / 100; // Convert 0..100 to 0..1

  // Weight: 40% sentiment, 40% coherence, 20% inverse arousal penalty for extremes
  const arousalPenalty = arousal > 70 ? (100 - arousal) / 100 : 1.0;
  hri = (sentimentNorm * 0.4) + (coherenceNorm * 0.4) + (arousalPenalty * 0.2);

  // Crisis penalty
  if (crisis === "risk") hri *= 0.3;
  else if (crisis === "uncertain") hri *= 0.7;

  // Clamp to 0.0-1.0
  hri = Math.max(0, Math.min(1, hri));

  return {
    // Core metrics
    words: wCount,
    sentiment,
    coherence,
    tone,
    mood,

    // Phase VIII.0: HRI (Hugo Resonance Index) - internal 0.0-1.0 scale
    hri,

    // Backward compatibility: legacy hugoScore (0-100)
    hugoScore: Math.round(hri * 100),

    // Phase VI enhancements
    valence,      // Circumplex x-axis (-100 to 100)
    arousal,      // Circumplex y-axis (0 to 100)
    resonance,    // Mixed emotion complexity (0-100)

    // Visual mapping
    hsv,          // [hue, saturation, vibrancy]

    // Ethical transparency
    confidence,   // Analysis confidence (0-100)
    crisis,       // "safe" | "uncertain" | "risk"
    crisisConfidence, // Crisis detection confidence (0-100)

    // Metadata
    flags: {
      shortText: wCount < 5,
      longText: wCount > 150,
      mixedEmotion: resonance > 40,
      highArousal: arousal > 70
    }
  };
}

// ═══════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════

function createEmptyResult() {
  return {
    words: 0,
    sentiment: 0,
    coherence: 50,
    tone: "neutral",
    mood: "reflective",
    hri: 0.5, // Neutral HRI
    hugoScore: 50, // Legacy compatibility
    valence: 0,
    arousal: 0,
    resonance: 0,
    hsv: [220, 0.3, 0.3],
    confidence: 0,
    crisis: "safe",
    crisisConfidence: 0,
    flags: { shortText: true, longText: false, mixedEmotion: false, highArousal: false }
  };
}

function calculateHSV(valence, arousal, coherence) {
  // Map circumplex space to HSV color
  let hue;

  if (arousal > 70) {
    // High arousal: urgent colors
    hue = valence > 0 ? 45 : 0; // Yellow (excited) or Red (distress)
  } else if (arousal < 30) {
    // Low arousal: calm colors
    hue = valence > 0 ? 180 : 220; // Cyan (peaceful) or Blue (melancholy)
  } else {
    // Medium arousal
    hue = valence > 0 ? 120 : 280; // Green (content) or Purple (complex)
  }

  const saturation = Math.min(1, (coherence / 100) + (arousal / 200));
  const vibrancy = Math.min(1, (arousal / 100) + (Math.abs(valence) / 200));

  return [
    Math.round(hue),
    Math.round(saturation * 100) / 100,
    Math.round(vibrancy * 100) / 100
  ];
}

function determineMood(sentiment, coherence, arousal, resonance, reflectCount, crisis) {
  // Priority 1: Crisis state
  if (crisis === "risk") return "urgent";

  // Priority 2: High arousal states
  if (arousal > 70) {
    return sentiment > 0 ? "charged" : "urgent";
  }

  // Priority 3: Complex/mixed emotions (Gemini's resonance)
  if (resonance > 50 && coherence > 60) {
    return "resonant"; // Harmonic complexity
  }

  // Priority 4: Clear emotional states
  if (sentiment > 30 && coherence > 70 && arousal < 50) {
    return "resonant"; // Peaceful positive
  }

  if (sentiment < -30 && coherence < 50) {
    return "dissonant"; // Chaotic negative
  }

  // Priority 5: Reflective states
  if (reflectCount >= 2 || (arousal < 40 && Math.abs(sentiment) < 20)) {
    return "reflective";
  }

  // Default: Dim (low energy, unclear)
  if (coherence < 50 && arousal < 40) {
    return "dim";
  }

  return "reflective";
}

/**
 * Legacy compatibility function
 * Maps new metrics to original mood taxonomy
 */
export function classifyMood(analysis) {
  const moodMap = {
    "resonant": "calm",
    "urgent": "urgent",
    "charged": "urgent",
    "dissonant": "dissonant",
    "reflective": "reflective",
    "dim": "dissonant"
  };

  return moodMap[analysis.mood] || "reflective";
}

export default { analyzeText, classifyMood };
